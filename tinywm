#!/usr/bin/env ruby
################################################################################
#
#   TinyWM is a simple little Ruby-based window manager based on the "original
#   tinywm" created by Nick Welch (http://incise.org/tinywm.html)
#
################################################################################

require 'rubygems'
require 'colorize'

require_relative 'xcb'

module TinyWM
  # Start the window manager and block until it's dead
  def self.run!
    connection = Xcb.connect(nil, nil)

    if connection.null?
      error 'Failed to open an X11 display!'
      return 1
    end

    log "Opened connection to display (#{connection})"

    screen = Xcb.first_screen(connection)
    log "Acquired root window: #{screen[:root]}"

    setup_keys_for(connection, screen[:root])

    begin
      event_loop(connection)
    rescue Interrupt
      log 'Exiting'
    rescue StandardError => ex
      error ex.inspect
      error ex.backtrace
    end

    return 0
  end

  def self.event_loop(connection)
    loop do
      event = Xcb.poll_for_event(connection)
      if event.null?
        sleep 0.2
        next
      end
      log 'event!'

      #handle_event(Xlib::Events.distinct_event_for(event))
    end
  end

  def self.handle_event(event)
    if event.is_a? Xlib::Events::KeyPress
      if event[:subwindow] != 0
        log 'raising window'
        Xlib.raise_window(event[:display], event[:window])
      end
    end

    if event.is_a? Xlib::Events::ButtonPress
      log 'button pressed!'
      Xlib.grab_pointer(event[:display],
                        event[:subwindow],
                        1,
                        (Xlib::Masks::POINTER_MOTION | Xlib::Masks::BUTTON_RELEASE),
                        Xlib::Mode::GRAB_MODE_ASYNC,
                        Xlib::Mode::GRAB_MODE_ASYNC,
                        0,
                        0,
                        0)

      # Need to hold onto this for the move
      @start_event = event
      @attrs = Xlib::WindowAttributes.new
      Xlib.window_attributes(event[:display],
                             event[:subwindow],
                             @attrs)
    end

    if event.is_a? Xlib::Events::ButtonRelease
      log 'button released'
      @start_event = nil
      @attrs = nil
      Xlib.ungrab_pointer(event[:display], 0)
    end

    if event.is_a? Xlib::Events::MotionNotify
      return if (@start_event.nil? || @attrs.nil?)

      x_diff = event[:x_root] - @start_event[:x_root]
      y_diff = event[:y_root] - @start_event[:y_root]
      x = @attrs[:x]
      y = @attrs[:y]
      width = @attrs[:width]
      height = @attrs[:height]

      if @start_event[:button] == 1 # left mouse
        x = (x + x_diff)
        y = (y + y_diff)
      elsif @start_event[:button] == 3 # right mouse
        width = [1, width + x_diff].max
        height = [1, height + y_diff].max
      else
        # lolwut
      end

      Xlib.move_or_resize_window(event[:display],
                                 event[:window],
                                 x,
                                 y,
                                 width,
                                 height)
    end
  end

  def self.setup_keys_for(connection, root_window)
    log 'Setting up keys'
    #xcb_grab_button(dpy, 0, root, XCB_EVENT_MASK_BUTTON_PRESS | 
    #            XCB_EVENT_MASK_BUTTON_RELEASE, XCB_GRAB_MODE_ASYNC, 
    #            XCB_GRAB_MODE_ASYNC, root, XCB_NONE, 1, XCB_MOD_MASK_1);

    cookie = Xcb.grab_button(connection,
                    0,
                    root_window,
                    Xcb::Masks::BUTTON_PRESS | Xcb::Masks::BUTTON_RELEASE,
                    Xcb::Masks::MODE_ASYNC,
                    Xcb::Masks::MODE_ASYNC,
                    root_window,
                    Xcb::Masks::NONE,
                    1,
                    Xcb::Masks::MOD_MASK_1)
    log "grab_button, cooke => #{cookie}"


  end

  def self.log(message)
    if message.is_a? Array
      message.each { |m| log(m) }
    else
      puts "[#{Time.now.utc}]>> #{message}"
    end
  end

  def self.error(message)
    if message.is_a? Array
      message.each { |m| error(m) }
    else
      puts "[#{Time.now.utc}]** #{message}".red
    end
  end
end


if $0 == __FILE__
  TinyWM.log "Starting TinyWM (#{RUBY_VERSION}:#{RUBY_PLATFORM})"
  exit TinyWM.run!
end
